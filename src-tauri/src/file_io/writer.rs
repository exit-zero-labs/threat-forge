use crate::errors::ThreatForgeError;
use crate::models::{DiagramLayout, ThreatModel};
use std::path::Path;

/// Write a threat model to a `.threatforge.yaml` file
pub fn write_threat_model(path: &Path, model: &ThreatModel) -> Result<(), ThreatForgeError> {
    // Add header comment
    let yaml =
        serde_yaml::to_string(model).map_err(|e| ThreatForgeError::YamlSerialize { source: e })?;

    let content = format!(
        "# ThreatForge Threat Model\n# Generated by ThreatForge v{}\n{}",
        env!("CARGO_PKG_VERSION"),
        yaml
    );

    // Ensure parent directory exists
    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent).map_err(|e| ThreatForgeError::FileWrite {
            path: parent.display().to_string(),
            source: e,
        })?;
    }

    std::fs::write(path, content).map_err(|e| ThreatForgeError::FileWrite {
        path: path.display().to_string(),
        source: e,
    })?;

    Ok(())
}

/// Write a diagram layout to a JSON file
pub fn write_layout(path: &Path, layout: &DiagramLayout) -> Result<(), ThreatForgeError> {
    // Ensure parent directory exists
    if let Some(parent) = path.parent() {
        std::fs::create_dir_all(parent).map_err(|e| ThreatForgeError::FileWrite {
            path: parent.display().to_string(),
            source: e,
        })?;
    }

    let json = serde_json::to_string_pretty(layout)
        .map_err(|e| ThreatForgeError::JsonSerialize { source: e })?;

    std::fs::write(path, json).map_err(|e| ThreatForgeError::FileWrite {
        path: path.display().to_string(),
        source: e,
    })?;

    Ok(())
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::file_io::read_threat_model;
    use crate::models::ThreatModel;
    use tempfile::TempDir;

    #[test]
    fn test_write_and_read_round_trip() {
        let dir = TempDir::new().unwrap();
        let path = dir.path().join("test.threatforge.yaml");

        let model = ThreatModel::new("Round Trip Test", "Test Author");
        write_threat_model(&path, &model).unwrap();

        let loaded = read_threat_model(&path).unwrap();
        assert_eq!(model.metadata.title, loaded.metadata.title);
        assert_eq!(model.metadata.author, loaded.metadata.author);
        assert_eq!(model.version, loaded.version);
    }

    #[test]
    fn test_write_creates_parent_directories() {
        let dir = TempDir::new().unwrap();
        let path = dir.path().join("nested/dir/test.threatforge.yaml");

        let model = ThreatModel::new("Nested Test", "Test Author");
        write_threat_model(&path, &model).unwrap();
        assert!(path.exists());
    }

    #[test]
    fn test_written_file_has_header_comment() {
        let dir = TempDir::new().unwrap();
        let path = dir.path().join("test.threatforge.yaml");

        let model = ThreatModel::new("Header Test", "Test Author");
        write_threat_model(&path, &model).unwrap();

        let content = std::fs::read_to_string(&path).unwrap();
        assert!(content.starts_with("# ThreatForge Threat Model"));
        assert!(content.contains("# Generated by ThreatForge"));
    }
}
